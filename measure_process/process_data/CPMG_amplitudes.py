import matplotlib.pyplot as plt
import numpy as np

from measure_process.Init_file import data_dump
from core_tools.data.ds.data_set import load_by_uuid
from measure_process.fits.T2_star import  Ramsey_formula, fit_CPMG
from measure_process.fits.CPMG_noise import  fit_Beta


#%%
def expected_amplitude(x,  T2):
    return np.exp(-(x / T2) ** 2)
    
def oscillation_part(x, amp, omega, phi, off):
    return amp*np.cos(2 * np.pi * omega*x + phi) + off


def normalize_nd_masks(params,t_wait, n, vis_limit=0.40,amp_limit=[0.1,0.9],plot=False):
    '''
    The function uses the fits of the oscillating CPMG to: normalize the trace using the cos fit, and fit amplitude decays for the CPMG-PSD

    Returns
    -------
    y_norm: normalized/recentered amplitude of the original CPMG trace
    y_final: CPMG trace in which all the points were brought in the 0-1 normalization window, instead of the symmetric oscillation pattern
    mask: the mask for the desired points to keep. needed to filter the CPMG trace 

    '''
    #oscillation values
    amp = params['amp'].value
    off = params['off'].value
    omega = params['omega'].value
    phi = params['phi'].value

    #decay values
    T2 = params['T2'].value

    
    
    
    osc_t = oscillation_part(t_wait,amp, omega, phi, off)
    osc_t = osc_t*0.5/amp
    osc_t = abs(osc_t - (off)*0.5/amp)
    cond1 = (osc_t >= vis_limit) #this conditions on the amplitude of the sine
    mask1 = np.where(cond1)
    
    amp_t = expected_amplitude(t_wait,T2)
    cond2 = ((amp_t>=amp_limit[0])&(amp_t<=amp_limit[1])) #this conditions on the amplitude of the sine
    mask2 = np.where(cond2)
    
    y_norm = y
    y_norm = y_norm*0.5/amp
    y_norm = y_norm - (off)*0.5/amp + 0.5
    
    
    
    y_final = y_norm - 0.5
    y_final = y_final*2 
    y_final = np.where((y_final < 0),y_final*-1,y_final)
    
    mask = np.where(cond1 & cond2)
    if plot:
        fig, ax = plt.subplots(1,2)
        ax[0].plot(t_wait,y_norm,'r.')
        ax[0].plot(t_wait,y_norm,'r-')
        ax[0].plot(t_wait[mask],y_norm[mask],'o')
        
        ax[1].plot(t_wait,amp_t,'-')
        ax[1].plot(t_wait[mask],y_final[mask],'o')
        plt.show()
    
    
    return y_norm, y_final, mask

def CPMG_PSD_amp(t_wait,y, n, plot=False):
    freqs = n/(2*t_wait)
    psd=-np.log(y)/(2*np.pi**2*t_wait)*0.08**2
    
    if plot:
        # plt.figure()
        plt.loglog(freqs,psd ,'o', label=f'N={n}')
        plt.legend()
    return freqs, psd
    

#%% 1 dataset averaged all

qubit = 1
plot = False 
# 1663537616171974076 ,1663537824142974076 ,1663538034238974076 ,1663538247219974076 ,1663538463252974076 
uuid = 1659009862711974087    
n=1
ds = load_by_uuid(uuid)
data_plotter(ds)
ds_avg = ds[f'read{qubit}'].average('x')
x,y = 1e-9*ds_avg.x()[:-1], ds_avg.y()[:-1]
params, errors = fit_CPMG(x,y, uuid, plot=plot)
print(errors['T2'])

y_norm,y_final, mask = normalize_nd_masks(params,x, n, vis_limit=0.47,amp_limit=[0.3,0.95],plot=True)

freqs,psd = CPMG_PSD_amp(x[mask],y_final[mask], n, plot=True)


#%% T2* 1Q Load data, multiple datasets
# temps = [200,250,300,350,400,450,500,550,600,650,700,750,800,850,900]
temps=[200]
num_pi = [2,4,8,16]

uuids = np.array([[1663538679829974076 ,1663538887758974076 ,1663539097309974076 ,1663539309681974076 ,1663539525372974076]])

#this dataset does not go to 950mK
qubit = 2
# uuids = np.array([[1663537616171974076 ,1663537824142974076 ,1663538034238974076 ,1663538247219974076 ,1663538463252974076 ],
#                   [1663540124340974076 ,1663540331673974076 ,1663540540815974076 ,1663540752883974076 ,1663540969769974076 ],
#                   [1663542613262974076 ,1663542822061974076 ,1663543032582974076 ,1663543246841974076 ,1663543465075974076 ],
#                   [1663545056932974076 ,1663545264298974076 ,1663545472812974076 ,1663545684732974076 ,1663545901274974076 ],
#                   [1663547484018974076 ,1663547692717974076 ,1663547903117974076 ,1663548117227974076 ,1663548335264974076 ],
#                   [1663549909127974076 ,1663550118976974076 ,1663550330545974076 ,1663550545548974076 ,1663550763991974076 ],
#                   [1663552331044974076 ,1663552538292974076 ,1663552747013974076 ,1663552957634974076 ,1663553173819974076 ],
#                   [1663554716823974076 ,1663554926021974076 ,1663555137195974076 ,1663555352166974076 ,1663555570738974076 ],
#                   [1663557118864974076 ,1663557326869974076 ,1663557536824974076 ,1663557749450974076 ,1663557967746974076 ],
#                   [1663559598558974076 ,1663559806297974076 ,1663560015770974076 ,1663560227137974076 ,1663560443689974076 ],
#                   [1663561979391974076 ,1663562187620974076 ,1663562397498974076 ,1663562610891974076 ,1663562829277974076 ],
#                   [1663564379163974076 ,1663564589543974076 ,1663564799951974076 ,1663565012703974076 ,1663565229720974076 ],
#                   [1663566784054974076 ,1663566995103974076 ,1663567205856974076 ,1663567420730974076 ,1663567638076974076 ],
#                   [1663569072404974076 ,1663569283474974076 ,1663569493413974076 ,1663569706685974076 ,1663569924384974076 ],
#                   [1663571358521974076 ,1663571569048974076 ,1663571777953974076 ,1663571990796974076 ,1663572208944974076 ]])


#this dataset does not go to 950mK
# qubit = 2
# uuids = np.array([[1663538679829974076 ,1663538887758974076 ,1663539097309974076 ,1663539309681974076 ,1663539525372974076 ],
#                   [1663541185708974076 ,1663541392343974076 ,1663541600409974076 ,1663541811284974076 ,1663542026216974076 ],
#                   [1663543681303974076 ,1663543891185974076 ,1663544100753974076 ,1663544313096974076 ,1663544528857974076 ],
#                   [1663546116982974076 ,1663546323742974076 ,1663546532498974076 ,1663546743149974076 ,1663546957254974076 ],
#                   [1663548552259974076 ,1663548760602974076 ,1663548971410974076 ,1663549183410974076 ,1663549399230974076 ],
#                   [1663550981761974076 ,1663551190827974076 ,1663551401141974076 ,1663551614955974076 ,1663551832149974076 ],
#                   [1663553385971974076 ,1663553591830974076 ,1663553798490974076 ,1663554008823974076 ,1663554223178974076 ],
#                   [1663555787555974076 ,1663555996703974076 ,1663556206951974076 ,1663556420894974076 ,1663556637826974076 ],
#                   [1663558183951974076 ,1663558392773974076 ,1663558601831974076 ,1663558813613974076 ,1663559029390974076 ],
#                   [1663560659589974076 ,1663560866797974076 ,1663561075471974076 ,1663561286388974076 ,1663561500332974076 ],
#                   [1663563045512974076 ,1663563253740974076 ,1663563462534974076 ,1663563674330974076 ,1663563889180974076 ],
#                   [1663565446936974076 ,1663565655328974076 ,1663565865856974076 ,1663566078283974076 ,1663566293335974076 ],
#                   [1663567855303974076 ,1663568063983974076 ,1663568274014974076 ,1663568485992974076 ,1663568702133974076 ],
#                   [1663570141031974076 ,1663570349737974076 ,1663570559670974076 ,1663570772064974076 ,1663570987936974076 ],
#                   [1663572425550974076 ,1663572634428974076 ,1663572843210974076 ,1663573055700974076 ,1663573271285974076 ],
#                   ])



# qubit =5
# uuids = np.array([[1659544709417974087 ,1659544881124974087 ,1659545053135974087 ,1659545227212974087 ,1659545405164974087 ],
#                   [1659575708318974087 ,1659575881035974087 ,1659576053296974087 ,1659576226742974087 ,1659576404198974087 ],
#                   [1659549145117974087 ,1659549317552974087 ,1659549489186974087 ,1659549663188974087 ,1659549840729974087 ],
#                   [1659579933712974087 ,1659580105175974087 ,1659580275970974087 ,1659580449880974087 ,1659580628004974087 ],
#                   [1659553516550974087 ,1659553688963974087 ,1659553860558974087 ,1659554034756974087 ,1659554212842974087 ],
#                   [1659584270520974087 ,1659584442543974087 ,1659584613994974087 ,1659584787849974087 ,1659584965206974087 ],
#                   [1659557861011974087 ,1659558033476974087 ,1659558204935974087 ,1659558379439974087 ,1659558557311974087 ],
#                   [1659588689876974087 ,1659588862455974087 ,1659589033883974087 ,1659589208438974087 ,1659589385994974087 ],
#                   [1659562177235974087 ,1659562350339974087 ,1659562521393974087 ,1659562695531974087 ,1659562873197974087 ],
#                   [1659592976408974087 ,1659593149217974087 ,1659593320620974087 ,1659593495287974087 ,1659593673179974087 ],
#                   [1659566497511974087 ,1659566669309974087 ,1659566841288974087 ,1659567015231974087 ,1659567191736974087 ],
#                   [1659597277778974087 ,1659597450045974087 ,1659597619993974087 ,1659597793358974087 ,1659597970676974087 ],
#                   [1659570828691974087 ,1659571001414974087 ,1659571173502974087 ,1659571347004974087 ,1659571525244974087 ],
#                   [1659601625175974087 ,1659601798926974087 ,1659601972141974087 ,1659602148478974087 ,1659602327764974087 ],
#                   [1659606034280974087 ,1659606208427974087 ,1659606381273974087 ,1659606556625974087 ,1659606735489974087 ],
#                   [1659610505015974087 ,1659610678016974087 ,1659610850373974087 ,1659611025588974087 ,1659611204428974087 ]])




# #650mk does not work
# qubit = 6
# uuids = np.array([[1659545582315974087 ,1659545753091974087 ,1659545924522974087 ,1659546098546974087 ,1659546277723974087 ],
#                   [1659576581006974087 ,1659576751035974087 ,1659576923039974087 ,1659577097209974087 ,1659577276394974087 ],
#                   [1659550016793974087 ,1659550186734974087, 1659550358616974087 ,1659550533603974087 ,1659550712132974087 ],
#                   [1659580804832974087 ,1659580974819974087 ,1659581146380974087 ,1659581320353974087 ,1659581498599974087 ],
#                   [1659554388983974087 ,1659554557917974087 ,1659554729736974087 ,1659554904285974087 ,1659555082593974087 ],
#                   [1659585141316974087 ,1659585311768974087 ,1659585484172974087 ,1659585658533974087 ,1659585837452974087 ],
#                   [1659558734070974087 ,1659558904329974087 ,1659559076615974087 ,1659559251691974087 ,1659559430016974087 ],
#                   [1659589562675974087 ,1659589733194974087 ,1659589905483974087 ,1659590079802974087 ,1659590258400974087 ],
#                   [1659563049424974087 ,1659563220219974087 ,1659563391740974087 ,1659563566163974087 ,1659563744808974087 ],
#                   [1659593849491974087 ,1659594019950974087 ,1659594192059974087 ,1659594367388974087 ,1659594546871974087 ],
#                   [1659567367750974087 ,1659567537581974087 ,1659567707734974087 ,1659567881973974087 ,1659568061006974087 ],
#                   [1659598146077974087 ,1659598315766974087 ,1659598486448974087 ,1659598660211974087 ,1659598837267974087 ],
#                   [1659571702080974087 ,1659571873115974087 ,1659572045717974087 ,1659572221412974087 ,1659572400570974087 ],
#                   [1659602506520974087 ,1659602678107974087 ,1659602851775974087 ,1659603028299974087 ,1659603209637974087 ],
#                   [1659606913280974087 ,1659607084380974087 ,1659607256645974087 ,1659607431256974087 ,1659607611386974087 ],
#                   [1659611382372974087 ,1659611554181974087 ,1659611727177974087 ,1659611903249974087 ,1659612083995974087 ]])

#%%##       

vis_limit = 0.45
amp_limit =[0.05,1]
for ii, uuid_temp  in enumerate(uuids):
    print(f'temp= {temps[ii]}mK')

    #prepare dictionary
    dic_data = {}
    # for n in num_pi:
    #     dic_data[f'freq_N={n}'] =None 
    #     dic_data[f'amp_N={n}'] =None
   
    
    for jj, uuid in enumerate(uuid_temp[:-1]):#this is because the sets have N=20 and i want to ignore it
        ds = load_by_uuid(int(uuid))
        ds_avg = ds[f'read{qubit}'].average('x')
        x,y = 1e-9*ds_avg.x()[:-1], ds_avg.y()[:-1]
        params,errors = fit_CPMG(x,y, uuid, plot=False)
        y_norm,y_final, mask = normalize_nd_masks(params,x, num_pi[jj], vis_limit=vis_limit,amp_limit=amp_limit,plot=True)
        freqs,psd = CPMG_PSD_amp(x[mask],y_final[mask], num_pi[jj], plot=False)
        
        dic_data[f'freq_N={num_pi[jj]}'] = freqs
        dic_data[f'amp_N={num_pi[jj]}'] = psd
        # dic_data[f'amp_{temps[ii]}mK'][jj] = abs(params['T2'].value)
        # dic_data['low'][jj] = errors['T2'][0]
        # dic_data['top'][jj] = errors['T2'][1]
    
    data_dump(dic_data,f'T2_CPMG/amplitudes/Q{qubit}',f'{temps[ii]}mK')    
    
    # keys = list(dic_data.keys())
    # params,errors = fit_Beta(dic_data[keys[0]], dic_data[keys[1]],temps[ii], plot=True)
    # dic_data2[f'Q{qubit}'][ii] = abs(params['beta'].value)
    # dic_data2['stderr'][ii] = params['beta'].stderr
    # print(errors['beta'])
    
    
    
    
    

#dump data
# data_dump(dic_data2,'T2_CPMG\amplitudes',f'Q{qubit}')
